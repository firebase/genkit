/**
 * Copyright 2025 Google LLC
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as assert from 'assert';
import { genkit, type Genkit } from 'genkit';
import { GoogleAuth } from 'google-auth-library';
import {
  after,
  afterEach,
  before,
  beforeEach,
  describe,
  it,
  mock,
} from 'node:test';
import {
  KNOWN_EMBEDDER_MODELS,
  VertexEmbeddingConfigSchema,
} from '../../src/vertexai/embedder.js';
import {
  GeminiConfigSchema,
  KNOWN_GEMINI_MODELS,
} from '../../src/vertexai/gemini.js';
import {
  ImagenConfigSchema,
  KNOWN_IMAGEN_MODELS,
} from '../../src/vertexai/imagen.js';
import { vertexAI } from '../../src/vertexai/index.js';
import { TEST_ONLY as UTILS_TEST_ONLY } from '../../src/vertexai/utils.js';

describe('VertexAI Plugin', () => {
  const originalMockDerivedOptions = {
    location: 'us-central1',
    projectId: 'test-project',
    authClient: {} as GoogleAuth,
  };

  before(() => {
    UTILS_TEST_ONLY.setMockDerivedOptions(originalMockDerivedOptions);
  });

  after(() => {
    UTILS_TEST_ONLY.setMockDerivedOptions(undefined as any);
  });

  describe('Initializer', () => {
    it('should pre-register flagship Gemini models', async () => {
      const ai = genkit({ plugins: [vertexAI()] });
      const model1Name = Object.keys(KNOWN_GEMINI_MODELS)[0];
      const model1Path = `/model/vertexai/${model1Name}`;
      const expectedBaseName = `vertexai/${model1Name}`;
      const model1 = await ai.registry.lookupAction(model1Path);
      assert.ok(model1, `${model1Name} should be registered at ${model1Path}`);
      assert.strictEqual(model1?.__action.name, expectedBaseName);
    });

    it('should register all known Gemini models', async () => {
      const ai = genkit({ plugins: [vertexAI()] });
      for (const modelName in KNOWN_GEMINI_MODELS) {
        const modelPath = `/model/vertexai/${modelName}`;
        const expectedBaseName = `vertexai/${modelName}`;
        const model = await ai.registry.lookupAction(modelPath);
        assert.ok(model, `${modelName} should be registered at ${modelPath}`);
        assert.strictEqual(model?.__action.name, expectedBaseName);
      }
    });

    it('should pre-register flagship Imagen models', async () => {
      const ai = genkit({ plugins: [vertexAI()] });
      const modelKeys = Object.keys(KNOWN_IMAGEN_MODELS);
      if (modelKeys.length > 0) {
        const model1Name = modelKeys[0];
        const model1Path = `/model/vertexai/${model1Name}`;
        const expectedBaseName = `vertexai/${model1Name}`;
        const model1 = await ai.registry.lookupAction(model1Path);
        assert.ok(
          model1,
          `${model1Name} should be registered at ${model1Path}`
        );
        assert.strictEqual(model1?.__action.name, expectedBaseName);
      }
    });

    it('should register all known Imagen models', async () => {
      const ai = genkit({ plugins: [vertexAI()] });
      for (const modelName in KNOWN_IMAGEN_MODELS) {
        const modelPath = `/model/vertexai/${modelName}`;
        const expectedBaseName = `vertexai/${modelName}`;
        const model = await ai.registry.lookupAction(modelPath);
        assert.ok(model, `${modelName} should be registered at ${modelPath}`);
        assert.strictEqual(model?.__action.name, expectedBaseName);
      }
    });

    it('should pre-register flagship Embedder models', async () => {
      const ai = genkit({ plugins: [vertexAI()] });
      const modelKeys = Object.keys(KNOWN_EMBEDDER_MODELS);
      if (modelKeys.length > 0) {
        const model1Name = modelKeys[0];
        const model1Path = `/embedder/vertexai/${model1Name}`;
        const expectedBaseName = `vertexai/${model1Name}`;
        const model1 = await ai.registry.lookupAction(model1Path);
        assert.ok(
          model1,
          `${model1Name} should be registered at ${model1Path}`
        );
        assert.strictEqual(model1?.__action.name, expectedBaseName);
      }
    });

    it('should register all known Embedder models', async () => {
      const ai = genkit({ plugins: [vertexAI()] });
      for (const modelName in KNOWN_EMBEDDER_MODELS) {
        const modelPath = `/embedder/vertexai/${modelName}`;
        const expectedBaseName = `vertexai/${modelName}`;
        const model = await ai.registry.lookupAction(modelPath);
        assert.ok(model, `${modelName} should be registered at ${modelPath}`);
        assert.strictEqual(model?.__action.name, expectedBaseName);
      }
    });
  });

  describe('Resolver via lookupAction', () => {
    const testModelName = 'gemini-100.0-pro';
    const testModelPath = `/model/vertexai/${testModelName}`;
    const testImagenName = 'imagen-100.0-generate';
    const testImagenPath = `/model/vertexai/${testImagenName}`;
    const testEmbedderName = 'text-embedding-100';
    const testEmbedderPath = `/embedder/vertexai/${testEmbedderName}`;

    it('should register a new Gemini model when looked up', async () => {
      const ai = genkit({ plugins: [vertexAI()] });
      const model = await ai.registry.lookupAction(testModelPath);
      assert.ok(model, `${testModelName} should be resolvable and registered`);
      assert.strictEqual(model?.__action.name, `vertexai/${testModelName}`);
    });

    it('should register a new Imagen model when looked up', async () => {
      const ai = genkit({ plugins: [vertexAI()] });
      const model = await ai.registry.lookupAction(testImagenPath);
      assert.ok(model, `${testImagenName} should be resolvable and registered`);
      assert.strictEqual(model?.__action.name, `vertexai/${testImagenName}`);
    });

    it('should register a new Embedder when looked up', async () => {
      const ai = genkit({ plugins: [vertexAI()] });
      const embedder = await ai.registry.lookupAction(testEmbedderPath);
      assert.ok(
        embedder,
        `${testEmbedderName} should be resolvable and registered`
      );
      assert.strictEqual(
        embedder?.__action.name,
        `vertexai/${testEmbedderName}`
      );
    });
  });

  describe('Helper Functions', () => {
    it('vertexAI.model should return a ModelReference for Gemini with correct schema', () => {
      const modelName = 'gemini-2.0-flash';
      const modelRef = vertexAI.model(modelName);
      assert.strictEqual(
        modelRef.name,
        `vertexai/${modelName}`,
        'Name should be prefixed'
      );
      assert.ok(
        modelRef.info?.supports?.multiturn,
        'Gemini model should support multiturn'
      );
      assert.strictEqual(
        modelRef.configSchema,
        GeminiConfigSchema,
        'Should have GeminiConfigSchema'
      );
    });

    it('vertexAI.model should return a ModelReference for Imagen with correct schema', () => {
      const modelName = 'imagen-3.0-generate-002';
      const modelRef = vertexAI.model(modelName);
      assert.strictEqual(
        modelRef.name,
        `vertexai/${modelName}`,
        'Name should be prefixed'
      );
      assert.ok(modelRef.info, 'Imagen model should have info');
      assert.strictEqual(
        modelRef.configSchema,
        ImagenConfigSchema,
        'Should have ImagenConfigSchema'
      );
    });

    it('vertexAI.model should handle custom names for Gemini family', () => {
      const modelName = 'gemini-custom-model';
      const modelRef = vertexAI.model(modelName);
      assert.strictEqual(modelRef.name, `vertexai/${modelName}`);
      assert.strictEqual(
        modelRef.configSchema,
        GeminiConfigSchema,
        'Custom Gemini should still use GeminiConfigSchema'
      );
    });

    it('vertexAI.model should handle custom names for Imagen family', () => {
      const modelName = 'imagen-custom-model';
      const modelRef = vertexAI.model(modelName);
      assert.strictEqual(modelRef.name, `vertexai/${modelName}`);
      assert.strictEqual(
        modelRef.configSchema,
        ImagenConfigSchema,
        'Custom Imagen should still use ImagenConfigSchema'
      );
    });

    it('vertexAI.embedder should return an EmbedderReference with correct schema', () => {
      const embedderName = 'text-embedding-005';
      const embedderRef = vertexAI.embedder(embedderName);
      assert.strictEqual(embedderRef.name, `vertexai/${embedderName}`);
      assert.ok(embedderRef.info, 'Should have info');
      assert.strictEqual(
        embedderRef.configSchema,
        VertexEmbeddingConfigSchema,
        'Should have VertexEmbeddingConfigSchema'
      );
    });
  });

  describe('listActions Function', () => {
    let fetchMock: any;
    let ai: Genkit;

    beforeEach(() => {
      ai = genkit({ plugins: [vertexAI()] });
      const authClientMock = {
        getAccessToken: async () => 'fake-test-token',
        // Add other methods if needed, though getAccessToken is the key one for headers
      };
      UTILS_TEST_ONLY.setMockDerivedOptions({
        location: 'us-central1',
        projectId: 'test-project',
        authClient: authClientMock as any,
      });
      fetchMock = mock.method(global, 'fetch');
    });

    afterEach(() => {
      fetchMock.mock.restore();
      UTILS_TEST_ONLY.setMockDerivedOptions(originalMockDerivedOptions);
    });

    const createMockResponse = (models: Array<{ name: string }>) => {
      return Promise.resolve({
        ok: true,
        json: async () => ({ publisherModels: models }),
      });
    };

    it('should return an empty array if no models are returned', async () => {
      fetchMock.mock.mockImplementation(async () => createMockResponse([]));
      const pluginProvider = vertexAI()(ai);
      const actions = await pluginProvider.listActions!();
      assert.deepStrictEqual(actions, [], 'Should return an empty array');
    });

    it('should return metadata for gemini and imagen models, filtering others', async () => {
      const mockModels = [
        { name: 'publishers/google/models/gemini-2.5-pro' },
        { name: 'publishers/google/models/imagen-3.0-generate-001' },
        { name: 'publishers/google/models/text-embedding-004' },
        { name: 'publishers/google/models/other-model' },
      ];
      fetchMock.mock.mockImplementation(async () =>
        createMockResponse(mockModels)
      );
      const pluginProvider = vertexAI()(ai);
      const actions = await pluginProvider.listActions!();
      const actionNames = actions.map((a) => a.name).sort();
      assert.deepStrictEqual(
        actionNames,
        ['vertexai/gemini-2.5-pro', 'vertexai/imagen-3.0-generate-001'].sort()
      );
      actions.forEach((action) => {
        assert.strictEqual(action.actionType, 'model');
      });
    });

    it('should filter out known decommissioned models', async () => {
      const mockModels = [
        { name: 'publishers/google/models/gemini-1.5-flash' },
        { name: 'publishers/google/models/gemini-pro' },
      ];
      fetchMock.mock.mockImplementation(async () =>
        createMockResponse(mockModels)
      );
      const pluginProvider = vertexAI()(ai);
      const actions = await pluginProvider.listActions!();
      const actionNames = actions.map((a) => a.name);
      assert.deepStrictEqual(actionNames, ['vertexai/gemini-1.5-flash']);
    });

    it('should filter out embedding models from gemini results', async () => {
      const mockModels = [
        { name: 'publishers/google/models/gemini-1.0-pro' },
        { name: 'publishers/google/models/gemini-embedding-001' },
      ];
      fetchMock.mock.mockImplementation(async () =>
        createMockResponse(mockModels)
      );
      const pluginProvider = vertexAI()(ai);
      const actions = await pluginProvider.listActions!();
      const actionNames = actions.map((a) => a.name);
      assert.deepStrictEqual(actionNames, ['vertexai/gemini-1.0-pro']);
    });

    it('should handle fetch errors gracefully', async () => {
      fetchMock.mock.mockImplementation(async () => {
        return Promise.resolve({
          ok: false,
          status: 500,
          statusText: 'Internal Error',
          json: async () => ({ error: { message: 'API Error' } }),
        });
      });
      const pluginProvider = vertexAI()(ai);
      const actions = await pluginProvider.listActions!();
      assert.deepStrictEqual(
        actions,
        [],
        'Should return empty array on fetch error'
      );
    });

    it('should use listActions cache', async () => {
      const mockModels = [{ name: 'publishers/google/models/gemini-1.0-pro' }];
      fetchMock.mock.mockImplementation(async () =>
        createMockResponse(mockModels)
      );
      const pluginProvider = vertexAI()(ai);
      await pluginProvider.listActions!();
      await pluginProvider.listActions!();
      assert.strictEqual(
        fetchMock.mock.callCount(),
        1,
        'fetch should only be called once'
      );
    });
  });
});
