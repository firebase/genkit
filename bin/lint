#!/usr/bin/env bash
# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# SPDX-License-Identifier: Apache-2.0

set -euo pipefail

TOP_DIR=$(git rev-parse --show-toplevel)

# shellcheck disable=SC2034
GO_DIR="${TOP_DIR}/go"  # Reserved for future Go linting
PY_DIR="${TOP_DIR}/py"
# shellcheck disable=SC2034
JS_DIR="${TOP_DIR}/js"  # Reserved for future JS linting

# â”€â”€ Phase 1: Sequential (modifies files) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ruff fix/format must complete before any read-only checks see the source.
uv run --directory "${PY_DIR}" ruff check --fix --preview --unsafe-fixes .
uv run --directory "${PY_DIR}" ruff format --preview .

echo "--- ðŸ”’ Checking lockfile is up to date ---"
uv lock --check --directory "${PY_DIR}"

# â”€â”€ Phase 2: Parallel read-only checks â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# All checks below are read-only and independent. Run them concurrently
# and collect results at the end.

TMPDIR_LINT=$(mktemp -d)
# shellcheck disable=SC2064
trap "rm -rf '${TMPDIR_LINT}'" EXIT

declare -a PIDS=()
declare -a NAMES=()

# Helper: launch a check in the background, capturing output.
run_check() {
  local name="$1"; shift
  local logfile="${TMPDIR_LINT}/${name}.log"
  (
    echo "--- ${name} ---"
    "$@" 2>&1
  ) > "${logfile}" 2>&1 &
  PIDS+=($!)
  NAMES+=("${name}")
}

# Type checkers
run_check "ðŸ” Ty Type Check"      uv run --directory "${PY_DIR}" ty check .
run_check "ðŸ” Pyrefly Type Check"  uv run --directory "${PY_DIR}" pyrefly check .
run_check "ðŸ” Pyright Type Check"  uv run --directory "${PY_DIR}" pyright packages/

# Security
run_check "ðŸ”’ Security Checks"     "${PY_DIR}/bin/run_python_security_checks"

# License
run_check "ðŸ“œ License Check"       "${TOP_DIR}/bin/check_license"
run_check "ðŸ“œ Dep License Check"   uv run --directory "${PY_DIR}" liccheck -s pyproject.toml

# Consistency + releasekit
run_check "ðŸ” Consistency Checks"  "${PY_DIR}/bin/check_consistency"
run_check "ðŸ“¦ Releasekit Checks"   uv run --directory "${TOP_DIR}/py/tools/releasekit" releasekit check

# Shellcheck (inline â€” slightly more complex, but still read-only)
_run_shellcheck() {
  if ! command -v shellcheck &> /dev/null; then
    echo "âš ï¸  shellcheck not installed (brew install shellcheck) - skipping"
    return 0
  fi
  local shell_errors=0
  local shell_scripts=()

  for script in "${TOP_DIR}"/bin/* "${PY_DIR}"/bin/*; do
    if [ -f "$script" ] && file "$script" | grep -qE "shell|bash|sh script" 2>/dev/null; then
      local script_name
      script_name=$(basename "$script")
      if [[ "$script_name" == *.py ]] || [[ "$script" == */.venv/* ]]; then
        continue
      fi
      shell_scripts+=("$script")
    fi
  done

  while IFS= read -r -d '' script; do
    shell_scripts+=("$script")
  done < <(find "${PY_DIR}/samples" -not -path '*/.venv/*' -name '*.sh' -type f -print0 2>/dev/null)

  for script in "${shell_scripts[@]}"; do
    if ! shellcheck -x -e SC1091 "$script" 2>&1; then
      shell_errors=$((shell_errors + 1))
    fi
  done

  if [ $shell_errors -gt 0 ]; then
    echo "âš ï¸  $shell_errors shell script(s) have shellcheck warnings"
    return 1
  else
    echo "âœ… All ${#shell_scripts[@]} shell scripts pass shellcheck"
  fi
}
run_check "ðŸš Shellcheck"  _run_shellcheck

# â”€â”€ Collect results â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
failures=0
for i in "${!PIDS[@]}"; do
  pid="${PIDS[$i]}"
  name="${NAMES[$i]}"
  if ! wait "${pid}"; then
    echo ""
    echo "âŒ FAILED: ${name}"
    cat "${TMPDIR_LINT}/${name}.log"
    failures=$((failures + 1))
  else
    echo "âœ… ${name}"
  fi
done

if [ $failures -gt 0 ]; then
  echo ""
  echo "âŒ ${failures} check(s) failed"
  exit 1
fi

# Disabled because there are many lint errors.
#pushd "${GO_DIR}" &>/dev/null
#golangci-lint run ./...
#go vet -v ./...
#popd &>/dev/null

#pnpm run -C ${JS_DIR} lint
