diff --git a/go/ai/generate.go b/go/ai/generate.go
index 75239ccff..3303a2d70 100644
--- a/go/ai/generate.go
+++ b/go/ai/generate.go
@@ -389,18 +389,7 @@ func GenerateWithRequest(ctx context.Context, r api.Registry, opts *GenerateActi
 				return resp, nil
 			}
 
-			finalResp, err := generate(ctx, newReq, currentTurn+1, currentIndex+1)
-			if err != nil {
-				return nil, err
-			}
-
-			if finalResp.Message != nil && resp.Message != nil {
-				var reasoningParts []*Part
-				reasoningParts = append(reasoningParts, resp.Message.Content...)
-				finalResp.Message.Content = append(reasoningParts, finalResp.Message.Content...)
-			}
-			return finalResp, nil
-			// return generate(ctx, newReq, currentTurn+1, currentIndex+1)
+			return generate(ctx, newReq, currentTurn+1, currentIndex+1)
 		})
 	}
 
@@ -766,16 +755,36 @@ func (mr *ModelResponse) History() []*Message {
 // Reasoning concatenates all reasoning parts present in the message
 func (mr *ModelResponse) Reasoning() string {
 	var sb strings.Builder
-	if mr.Message == nil {
-		return ""
+
+	// We want to capture reasoning from the entire "turn", which might include
+	// multiple model responses (due to tool use) since the last user message.
+	history := mr.History()
+	startIdx := 0
+
+	// Find the index of the last User message. We only care about reasoning
+	// generated by the model in response to *that* message.
+	for i := len(history) - 1; i >= 0; i-- {
+		if history[i].Role == RoleUser {
+			startIdx = i + 1
+			break
+		}
 	}
 
-	for _, p := range mr.Message.Content {
-		if !p.IsReasoning() {
+	// Iterate through all subsequent messages (Model and Tool roles)
+	for i := startIdx; i < len(history); i++ {
+		msg := history[i]
+		// Only look for reasoning in Model messages
+		if msg.Role != RoleModel {
 			continue
 		}
-		sb.WriteString(p.Text)
+		for _, p := range msg.Content {
+			if !p.IsReasoning() {
+				continue
+			}
+			sb.WriteString(p.Text)
+		}
 	}
+
 	return sb.String()
 }
 
